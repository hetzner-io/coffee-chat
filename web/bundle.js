;(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
(function(global){// Generated by CoffeeScript 1.6.1
(function() {
  var store;

  store = require('store');

  document.addEventListener('DOMContentLoaded', function() {
    var sendPacket, serverMessagingProtocol, socket, userInputProtocol, viewModel;
    window.addEventListener('keydown', function(e) {
      if (e.keyCode === 27) {
        return e.preventDefault();
      }
    });
    socket = io.connect();
    sendPacket = function(data) {
      return socket.emit('data', data);
    };
    viewModel = {
      identity: ko.observable(),
      members: ko.observableArray(),
      messages: ko.observableArray(),
      messageAdded: function(element, index, data) {
        element.parentNode.scrollTop = element.parentNode.scrollHeight;
        try {
          return $(element).effect('highlight');
        } catch (_error) {}
      },
      input: ko.observable(),
      isInputBoxSelected: ko.observable(true),
      inputSubmitted: function(form) {
        var text, _ref;
        if (text = (_ref = this.input()) != null ? _ref.trim() : void 0) {
          return ko.postbox.publish('viewModel.inputSubmitted', text);
        }
      },
      inputKeyUp: function(data, event) {
        return ko.postbox.publish('viewModel.inputKeyUp', event.keyCode);
      }
    };
    ko.applyBindings(viewModel);
    global.viewModel = viewModel;
    userInputProtocol = function() {
      var inputHistory;
      inputHistory = {
        elements: ko.observableArray(),
        idx: ko.observable(1),
        push: function(text) {
          this.elements.push(text);
          return this.escape();
        },
        up: function() {
          if (this.idx() !== 0) {
            return this.idx(this.idx() - 1);
          }
        },
        down: function() {
          if (this.idx() !== this.elements().length) {
            return this.idx(this.idx() + 1);
          }
        },
        escape: function() {
          return this.idx(this.elements().length);
        },
        currentSelection: function() {
          if (this.idx() < this.elements().length) {
            return this.elements()[this.idx()];
          } else {
            return '';
          }
        }
      };
      inputHistory.selected = ko.computed(function() {
        return inputHistory.currentSelection();
      });
      inputHistory.selected.subscribe(function(text) {
        return viewModel.input(text);
      });
      ko.postbox.subscribe('viewModel.inputSubmitted', function(text) {
        return inputHistory.push(text);
      });
      ko.postbox.subscribe('viewModel.inputKeyUp', function(keyCode) {
        switch (keyCode) {
          case 27:
            return inputHistory.escape();
          case 38:
            return inputHistory.up();
          case 40:
            return inputHistory.down();
        }
      });
      return ko.postbox.subscribe('viewModel.inputSubmitted', function(text) {
        var match;
        if (match = text.match(/^\/nick\s+(.+)/)) {
          return sendPacket({
            action: 'identify',
            data: match[1]
          });
        } else if (text.match(/^\//)) {
          return viewModel.messages.push({
            action: 'error',
            data: "Bad command: " + text
          });
        } else {
          return sendPacket({
            action: 'say',
            data: text
          });
        }
      });
    };
    userInputProtocol();
    serverMessagingProtocol = function() {
      return socket.on('data', function(data) {
        var i, preferred;
        switch (data.action) {
          case 'welcome':
            viewModel.identity(data.data);
            if (preferred = store.get('identity')) {
              sendPacket({
                action: 'identify',
                data: preferred
              });
            }
            break;
          case 'identify':
            if (data.sender === viewModel.identity()) {
              viewModel.identity(data.data);
              store.set('identity', viewModel.identity());
            }
        }
        if (['welcome', 'connect', 'disconnect', 'identify', 'say', 'error'].indexOf(data.action) >= 0) {
          if (viewModel.messages().length >= 1000) {
            viewModel.messages.shift();
          }
          viewModel.messages.push({
            sender: data.sender,
            action: data.action,
            data: data.data
          });
        }
        switch (data.action) {
          case 'welcome':
            return sendPacket({
              action: 'members'
            });
          case 'members':
            return viewModel.members(data.data);
          case 'connect':
            return viewModel.members.push(data.sender);
          case 'disconnect':
            return viewModel.members.remove(data.sender);
          case 'identify':
            if ((i = viewModel.members.indexOf(data.sender)) >= 0) {
              return viewModel.members.splice(i, 1, data.data);
            }
        }
      });
    };
    return serverMessagingProtocol();
  });

}).call(this);

})(window)
},{"store":2}],2:[function(require,module,exports){
/* Copyright (c) 2010-2012 Marcus Westin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

;(function(){
	var store = {},
		win = window,
		doc = win.document,
		localStorageName = 'localStorage',
		namespace = '__storejs__',
		storage

	store.disabled = false
	store.set = function(key, value) {}
	store.get = function(key) {}
	store.remove = function(key) {}
	store.clear = function() {}
	store.transact = function(key, defaultVal, transactionFn) {
		var val = store.get(key)
		if (transactionFn == null) {
			transactionFn = defaultVal
			defaultVal = null
		}
		if (typeof val == 'undefined') { val = defaultVal || {} }
		transactionFn(val)
		store.set(key, val)
	}
	store.getAll = function() {}

	store.serialize = function(value) {
		return JSON.stringify(value)
	}
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		try { return JSON.parse(value) }
		catch(e) { return value || undefined }
	}

	// Functions to encapsulate questionable FireFox 3.6.13 behavior
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]) }
		catch(err) { return false }
	}

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName]
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setItem(key, store.serialize(val))
			return val
		}
		store.get = function(key) { return store.deserialize(storage.getItem(key)) }
		store.remove = function(key) { storage.removeItem(key) }
		store.clear = function() { storage.clear() }
		store.getAll = function() {
			var ret = {}
			for (var i=0; i<storage.length; ++i) {
				var key = storage.key(i)
				ret[key] = store.get(key)
			}
			return ret
		}
	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile')
			storageContainer.open()
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></frame>')
			storageContainer.close()
			storageOwner = storageContainer.w.frames[0].document
			storage = storageOwner.createElement('div')
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div')
			storageOwner = doc.body
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0)
				args.unshift(storage)
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage)
				storage.addBehavior('#default#userData')
				storage.load(localStorageName)
				var result = storeFunction.apply(store, args)
				storageOwner.removeChild(storage)
				return result
			}
		}

		// In IE7, keys may not contain special chars. See all of https://github.com/marcuswestin/store.js/issues/40
		var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
		function ieKeyFix(key) {
			return key.replace(forbiddenCharsRegex, '___')
		}
		store.set = withIEStorage(function(storage, key, val) {
			key = ieKeyFix(key)
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val))
			storage.save(localStorageName)
			return val
		})
		store.get = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			return store.deserialize(storage.getAttribute(key))
		})
		store.remove = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			storage.removeAttribute(key)
			storage.save(localStorageName)
		})
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes
			storage.load(localStorageName)
			for (var i=0, attr; attr=attributes[i]; i++) {
				storage.removeAttribute(attr.name)
			}
			storage.save(localStorageName)
		})
		store.getAll = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes
			storage.load(localStorageName)
			var ret = {}
			for (var i=0, attr; attr=attributes[i]; ++i) {
				ret[attr] = store.get(attr)
			}
			return ret
		})
	}

	try {
		store.set(namespace, namespace)
		if (store.get(namespace) != namespace) { store.disabled = true }
		store.remove(namespace)
	} catch(e) {
		store.disabled = true
	}
	store.enabled = !store.disabled

	if (typeof module != 'undefined' && typeof module != 'function') { module.exports = store }
	else if (typeof define === 'function' && define.amd) { define(store) }
	else { this.store = store }
})();

},{}]},{},[1])
;